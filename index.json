[{"content":"The Rust ecosystem has numerous platforms and extensive documentation to support cross-compilation features.\nBut does it work as expected?\nWell, if your binary has few shared library dependencies, then it likely will. Compiling for x86_64-unknown-linux-musl significantly increases the likelihood that your binary will operate across different Linux distributions.\nHowever, the reality in production can be quite different. We still encounter dependency hell, and many Rust crates rely on shared libraries that may have varying names and paths.\nOne of my projects has about 120 dependencies on shared library and codebase of this project is not big (It has around 10k lines with tests). (Despite my effors to minimize the amount of dependencies.)\nTo verify dependencies, I use the ldd Linux utility:\nldd \u0026lt;path_to_binary\u0026gt; libssl.so.3 =\u0026gt; /lib/x86_64-linux-gnu/libssl.so.3 (0x00007f912c971000) libcrypto.so.3 =\u0026gt; /lib/x86_64-linux-gnu/libcrypto.so.3 (0x00007f9129800000) ... libkeyutils.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libkeyutils.so.1 (0x00007f9124096000) libresolv.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f91239f9000) libquadmath.so.0 =\u0026gt; /lib/x86_64-linux-gnu/libquadmath.so.0 (0x00007f9121bb9000) So, what are the chances that this binary, built on Debian 12, will work with Ubuntu 22.04, for example? (This question is rhetorical.)\nProblem The challenge is to build a binary, deliver it, and run it on an Ubuntu 22.04 VPS (or any other Linux distro you prefer) with only runtime dependencies.\nSolution Build binary in docker and export it to VPS.\nThe docker file that builds hello_world binary could looks something like:\nFROM ubuntu:22.04 AS build-stage ENV DEBIAN_FRONTEND=noninteractive # Install required dependencies RUN apt-get update \u0026amp;\u0026amp; apt-get install -y --no-install-recommends \\ \u0026lt;package_name\u0026gt;... # A list of deps used to build binary \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* RUN curl https://sh.rustup.rs -sSf | bash -s -- -y # Set the working directory inside the container WORKDIR /usr/src/app/ COPY . . RUN SQLX_OFFLINE=true ~/.cargo/bin/cargo build --release FROM scratch AS export-stage COPY --from=build-stage /usr/src/app/target/release/hello_world CMD [\u0026#34;/bin/bash\u0026#34;] The build command docker build -f \u0026lt;your_docker_file_name\u0026gt; --output=bin . will deliver the built binary to bin directory.\nThen, you can use the scp utility to transfer this binary to your VPS.\nIf the binary requires certain shared libraries, you will need to install them with your package manager (in case of ubuntu apt or apt-get)\n","permalink":"https://kurotych.com/posts/distributing-rust-binaries/","summary":"The Rust ecosystem has numerous platforms and extensive documentation to support cross-compilation features.\nBut does it work as expected?\nWell, if your binary has few shared library dependencies, then it likely will. Compiling for x86_64-unknown-linux-musl significantly increases the likelihood that your binary will operate across different Linux distributions.\nHowever, the reality in production can be quite different. We still encounter dependency hell, and many Rust crates rely on shared libraries that may have varying names and paths.","title":"Building and Deploying Rust Binaries Across Linux Distributions."},{"content":"Almost all software developers use databases in their daily routines.\nThe inconveniences can come when you need to work with different types of databases or different versions. Fortunately, there is a common way to work with all popular databases.\nPrerequirements: Linux, Docker.\n1. Start database server and DB management tool With docker, you can run whatever database you want without installation hassle.\nLet\u0026rsquo;s take the PostgreSQL db as an example.\nRun ✦❯ docker run --name some-postgres -e POSTGRES_PASSWORD=pswd -e POSTGRES_USER=user -e POSTGRES_DB=pdb -d --network=host postgres:15.3 70c2e363683fe9de108642e5f7140cd03d2ab0b117c8a3520c7a8ce6e7c10cca After this command you should have the DB server started on your localhost with created user: user and database: pdb on 5432 port.\nTo check it you can use telnet:\n✦❯ telnet localhost 5432 Trying ::1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. 2. Start DB management tool (Frontend) Now we have a running PostgreSQL server and it\u0026rsquo;s time to use frontend. You need just start another docker container with adminer.\nRun ✦❯ docker run -d --network=host adminer c30e0215855e3926162749bde3a606a0ce20c4374abc688a665e604c78a64e66 The adminer is successfully run. Go to http://localhost:8080/\n3. Analyze and share DB structure To easily analyze and share with colleagues your DB structure you can use sqlant\n","permalink":"https://kurotych.com/posts/improve_psql_routine/","summary":"Almost all software developers use databases in their daily routines.\nThe inconveniences can come when you need to work with different types of databases or different versions. Fortunately, there is a common way to work with all popular databases.\nPrerequirements: Linux, Docker.\n1. Start database server and DB management tool With docker, you can run whatever database you want without installation hassle.\nLet\u0026rsquo;s take the PostgreSQL db as an example.","title":"Improve software development routine. Local database setup."},{"content":"Prerequirements You know how to setup and configure neovim plugins. You use UNIX-like OS Step-by-Step guide Install the next neovim plugins nvim-dap nvim-dap-ui -- Example with packer.nvim use(\u0026#34;mfussenegger/nvim-dap\u0026#34;) use { \u0026#34;rcarriga/nvim-dap-ui\u0026#34;, requires = {\u0026#34;mfussenegger/nvim-dap\u0026#34;} } Install vscode-lldb\nDownload file specific to your system https://github.com/vadimcn/vscode-lldb/releases Unpack it by unzip utility. In my case I unpacked it to ~/Sources/lldb The result of execution unzip codelldb-x86_64-linux.vsix in ~/Sources/lldb: codelldb execution file is available by path: ~/Sources/lldb/extension/adapter Configure nvim-dap in your init.lua\nlocal dap = require(\u0026#34;dap\u0026#34;) dap.adapters.codelldb = { type = \u0026#39;server\u0026#39;, port = \u0026#34;${port}\u0026#34;, executable = { -- Change this to your path! command = \u0026#39;/home/kurotych/Sources/lldb/extension/adapter/codelldb\u0026#39;, args = {\u0026#34;--port\u0026#34;, \u0026#34;${port}\u0026#34;}, } } dap.configurations.rust= { { name = \u0026#34;Launch file\u0026#34;, type = \u0026#34;codelldb\u0026#34;, request = \u0026#34;launch\u0026#34;, program = function() return vim.fn.input(\u0026#39;Path to executable: \u0026#39;, vim.fn.getcwd() .. \u0026#39;/\u0026#39;, \u0026#39;file\u0026#39;) end, cwd = \u0026#39;${workspaceFolder}\u0026#39;, stopOnEntry = false, }, } require(\u0026#34;dapui\u0026#34;).setup({}) Open any rust program and execute in neovim command line :lua require(\u0026quot;dap\u0026quot;).toggle_breakpoint() where you can stop your program Screenshot Run :lua require(\u0026quot;dap\u0026quot;).continue() in neovim command line to start debugging\nScreenshot Run :lua require(\u0026quot;dapui\u0026quot;).open()\nScreenshot You can navigate through debug windows by mouse.\nExecte :lua require(\u0026quot;dapui\u0026quot;).close() - to close all debug windows Keybindings local dap = require(\u0026#39;dap\u0026#39;) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;F5\u0026gt;\u0026#39;, function() dap.continue() end) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;F10\u0026gt;\u0026#39;, function() dap.step_over() end) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;F11\u0026gt;\u0026#39;, function() dap.step_into() end) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;F12\u0026gt;\u0026#39;, function() dap.step_out() end) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;Leader\u0026gt;b\u0026#39;, function() dap.toggle_breakpoint() end) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;Leader\u0026gt;dl\u0026#39;, function() dap.run_last() end) vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;Leader\u0026gt;df\u0026#39;, function() require(\u0026#34;dapui\u0026#34;).float_element(\u0026#39;scopes\u0026#39;, { enter = true }) end) Additional info You can find at plugins repositories nvim-dap and nvim-dap-ui\ndapui float_element Screenshot ","permalink":"https://kurotych.com/posts/rust_neovim_debugger/","summary":"Prerequirements You know how to setup and configure neovim plugins. You use UNIX-like OS Step-by-Step guide Install the next neovim plugins nvim-dap nvim-dap-ui -- Example with packer.nvim use(\u0026#34;mfussenegger/nvim-dap\u0026#34;) use { \u0026#34;rcarriga/nvim-dap-ui\u0026#34;, requires = {\u0026#34;mfussenegger/nvim-dap\u0026#34;} } Install vscode-lldb\nDownload file specific to your system https://github.com/vadimcn/vscode-lldb/releases Unpack it by unzip utility. In my case I unpacked it to ~/Sources/lldb The result of execution unzip codelldb-x86_64-linux.vsix in ~/Sources/lldb: codelldb execution file is available by path: ~/Sources/lldb/extension/adapter Configure nvim-dap in your init.","title":"Minimal Setup: Configuring Rust Debugger in Neovim"},{"content":"Technologies This site hosted by github pages and built by hugo plus hugo-PaperMod theme.\nHugo I choose Hugo because it\u0026rsquo;s fast, and I like the simplicity of filling the site content with Markdown. Having i18n out-of-box also a big advantage of this tool.\nGithub pages Provides ready to use CI/CD process. Which means my site automatically updates after commit pushed to repository.1\nCosts It costs my only price of domain kurotych.com\nHelpful links Hosting Hugo on Github GitHub Pages with Namecheap custom domain You need to have configured workflow in your repository. Check the gh-pages.yml\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://kurotych.com/posts/how-i-built-this-site1/","summary":"Technologies This site hosted by github pages and built by hugo plus hugo-PaperMod theme.\nHugo I choose Hugo because it\u0026rsquo;s fast, and I like the simplicity of filling the site content with Markdown. Having i18n out-of-box also a big advantage of this tool.\nGithub pages Provides ready to use CI/CD process. Which means my site automatically updates after commit pushed to repository.1\nCosts It costs my only price of domain kurotych.","title":"Tech description of this site"}]